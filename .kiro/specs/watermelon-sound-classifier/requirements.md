# 요구사항 문서

## 개요

이 프로젝트는 수박의 숙성도에 따른 소리를 분류하는 파이썬 기반 머신러닝 파이프라인을 개발하는 것입니다. 시스템은 서로 다른 숙성 단계를 나타내는 세 가지 수박 유형(watermelon_A, watermelon_B, watermelon_C)의 오디오 데이터를 분석합니다. 핵심 목표는 소음 증강 기법을 통해 실제 환경 조건을 처리할 수 있는 강건한 모델을 구축하여 다양한 음향 환경에서 신뢰할 수 있는 분류 성능을 보장하는 것입니다.

## 데이터 디렉토리 구조

프로젝트에서 사용할 오디오 파일들은 다음과 같은 구조로 배치되어야 합니다:

```
data/
├── raw/
│   ├── train/                 # 훈련용 데이터 (70%)
│   │   ├── watermelon_A/      # 수박 A 유형 (예: 덜 익은 수박)
│   │   │   ├── sample_001.wav
│   │   │   ├── sample_002.wav
│   │   │   └── ...
│   │   ├── watermelon_B/      # 수박 B 유형 (예: 적당히 익은 수박)
│   │   │   ├── sample_001.wav
│   │   │   ├── sample_002.wav
│   │   │   └── ...
│   │   └── watermelon_C/      # 수박 C 유형 (예: 잘 익은 수박)
│   │       ├── sample_001.wav
│   │       ├── sample_002.wav
│   │       └── ...
│   ├── validation/            # 검증용 데이터 (20%)
│   │   ├── watermelon_A/
│   │   │   ├── sample_001.wav
│   │   │   └── ...
│   │   ├── watermelon_B/
│   │   │   ├── sample_001.wav
│   │   │   └── ...
│   │   └── watermelon_C/
│   │       ├── sample_001.wav
│   │       └── ...
│   └── test/                  # 테스트용 데이터 (10%)
│       ├── watermelon_A/
│       │   ├── sample_001.wav
│       │   └── ...
│       ├── watermelon_B/
│       │   ├── sample_001.wav
│       │   └── ...
│       └── watermelon_C/
│           ├── sample_001.wav
│           └── ...
├── noise/                     # 소음 파일들
│   ├── environmental/         # 환경 소음
│   │   └── retail/            # 소매점/마트 환경 소음
│   │       ├── homeplus/      # 홈플러스 환경 소음
│   │       │   ├── homeplus_ambient_01.wav
│   │       │   ├── homeplus_crowd_01.wav
│   │       │   └── ...
│   │       └── emart/         # 이마트 환경 소음
│   │           ├── emart_ambient_01.wav
│   │           ├── emart_crowd_01.wav
│   │           └── ...
│   ├── mechanical/            # 기계 소음 (선택사항, 파일 없어도 무관)
│   └── background/            # 배경 소음 (선택사항, 파일 없어도 무관)
├── processed/                 # 처리된 파일들 (자동 생성)
│   ├── augmented/             # 증강된 훈련 데이터만 저장
│   │   ├── watermelon_A/
│   │   ├── watermelon_B/
│   │   └── watermelon_C/
│   ├── features/              # 추출된 특징 파일
│   └── splits/                # 데이터 분할 정보 (메타데이터)
└── models/                    # 훈련된 모델들 (자동 생성)
    ├── svm_model.pkl
    ├── random_forest_model.pkl
    ├── svm_model.mlmodel
    └── random_forest_model.mlmodel
```

### 파일 요구사항:
- **원본 수박 소리**: 각 클래스(watermelon_A, B, C)당 최소 20개 이상의 .wav 파일
- **소음 파일**: 
  - 홈플러스 환경 소음: data/noise/environmental/retail/homeplus/ 디렉토리에 배치
  - 이마트 환경 소음: data/noise/environmental/retail/emart/ 디렉토리에 배치
  - 각 환경별로 최소 3개 이상의 .wav 파일 권장
  - mechanical/, background/ 폴더는 선택사항이며, 소음 파일이 없어도 시스템이 정상 동작함
- **오디오 형식**: 모든 파일은 .wav 형식, 16-bit PCM, 22050Hz 또는 44100Hz 샘플링 레이트 권장

## 요구사항

### 요구사항 1: 오디오 특징 추출

**사용자 스토리:** 머신러닝 엔지니어로서, 수박 소리 녹음에서 포괄적인 오디오 특징을 추출하여 분류 모델에 의미 있는 입력 데이터를 제공하고 싶습니다.

#### 수락 기준

1. .wav 오디오 파일이 제공될 때 시스템은 librosa를 사용하여 MFCC(Mel-Frequency Cepstral Coefficients) 특징을 추출해야 합니다
2. 오디오 데이터를 처리할 때 시스템은 평균과 표준편차를 포함한 Mel Spectrogram 요약 통계를 계산해야 합니다
3. 오디오 신호를 분석할 때 시스템은 Spectral Centroid 값을 계산해야 합니다
4. 오디오 파일을 처리할 때 시스템은 Spectral Rolloff 특징을 추출해야 합니다
5. 오디오 데이터를 분석할 때 시스템은 Zero Crossing Rate 측정값을 계산해야 합니다
6. 오디오 신호를 처리할 때 시스템은 Chroma Features를 추출해야 합니다
7. 모든 특징이 추출되면 시스템은 모델 입력을 위해 단일 특징 벡터로 반환해야 합니다

### 요구사항 2: 소음을 이용한 데이터 증강

**사용자 스토리:** 데이터 사이언티스트로서, 다양한 소음 유형과 레벨로 깨끗한 오디오 데이터를 증강하여 모델이 실제 환경 조건에 대해 강건하게 만들고 싶습니다.

#### 수락 기준

1. 깨끗한 오디오와 소음 파일이 제공될 때 시스템은 지정된 SNR(Signal-to-Noise Ratio) 값(dB)을 기반으로 이들을 결합해야 합니다
2. SNR 매개변수가 지정될 때 시스템은 목표 SNR을 달성하기 위해 소음 레벨을 동적으로 조정해야 합니다
3. 단일 원본 오디오 파일을 증강할 때 시스템은 다양한 소음 유형과 SNR 레벨을 사용하여 여러 변형을 생성해야 합니다
4. 증강된 데이터를 생성할 때 시스템은 원본 오디오의 분류 레이블을 보존해야 합니다
5. 소음 증강이 적용될 때 시스템은 특징 추출에 적합한 오디오 품질을 유지해야 합니다

### 요구사항 3: 머신러닝 모델 훈련 및 평가

**사용자 스토리:** 머신러닝 실무자로서, 추출된 오디오 특징에 대해 분류 모델을 훈련하고 평가하여 소리를 기반으로 수박 유형을 정확하게 분류하고 싶습니다.

#### 수락 기준

1. 특징 벡터가 사용 가능할 때 시스템은 scikit-learn을 사용하여 Support Vector Machine(SVM) 분류기를 훈련해야 합니다
2. 훈련 데이터가 제공될 때 시스템은 scikit-learn을 사용하여 Random Forest 분류기를 훈련해야 합니다
3. 모델이 훈련될 때 시스템은 정확도와 F1-score 메트릭을 사용하여 성능을 평가해야 합니다
4. 파이프라인을 구현할 때 시스템은 향후 CNN과 RNN/LSTM 모델의 통합을 허용하도록 구조화되어야 합니다
5. 모델을 평가할 때 시스템은 SVM과 Random Forest 간의 비교 성능 분석을 제공해야 합니다

### 요구사항 4: 데이터 분할 및 파이프라인 구현

**사용자 스토리:** 데이터 사이언티스트로서, 데이터 누출을 방지하는 적절히 구조화된 데이터 파이프라인을 원하여 신뢰할 수 있고 편향되지 않은 모델 성능 추정치를 얻고 싶습니다.

#### 수락 기준

1. 원본 오디오 파일이 data/raw/train/, data/raw/validation/, data/raw/test/ 디렉토리에 이미 분할되어 있을 때 시스템은 각 디렉토리에서 클래스별 파일을 로드해야 합니다
2. 데이터 분할이 완료될 때 시스템은 훈련 세트에만 data/noise/ 디렉토리의 사용 가능한 소음 파일을 사용하여 증강을 적용해야 합니다
3. 증강이 적용될 때 시스템은 원본 훈련 샘플당 약 4개의 추가 샘플을 생성해야 합니다
4. 특징 추출이 발생할 때 시스템은 증강된 훈련 데이터, 원본 검증 데이터, 원본 테스트 데이터를 별도로 처리해야 합니다
5. 파이프라인이 실행될 때 시스템은 검증 또는 테스트 세트의 데이터가 훈련 데이터 증강에 영향을 주지 않도록 보장해야 합니다

### 요구사항 5: 교차 검증 및 모델 최적화

**사용자 스토리:** 머신러닝 엔지니어로서, 모델 훈련 중에 교차 검증을 사용하여 하이퍼파라미터를 최적화하고 모델 일반화를 개선하고 싶습니다.

#### 수락 기준

1. 모델을 훈련할 때 시스템은 K=5인 K-Fold 교차 검증을 구현해야 합니다
2. 교차 검증이 수행될 때 시스템은 증강된 훈련 세트만 사용해야 합니다
3. 하이퍼파라미터를 최적화할 때 시스템은 교차 검증 성능을 기반으로 최적의 매개변수를 선택해야 합니다
4. 교차 검증이 완료될 때 시스템은 전체 증강된 훈련 세트에서 최적의 하이퍼파라미터를 사용하여 최종 모델을 훈련해야 합니다

### 요구사항 6: 최종 모델 평가 및 보고

**사용자 스토리:** 프로젝트 이해관계자로서, 보지 못한 테스트 데이터에 대한 포괄적인 성능 평가를 원하여 분류 시스템의 실제 효과를 평가하고 싶습니다.

#### 수락 기준

1. 최종 모델이 훈련될 때 시스템은 원본(비증강) 테스트 세트에서 이들을 평가해야 합니다
2. 평가가 수행될 때 시스템은 각 모델에 대해 정확도, 정밀도, 재현율, F1-score를 보고해야 합니다
3. 테스트가 완료될 때 시스템은 상세한 성능 분석을 위해 혼동 행렬을 제공해야 합니다
4. 최종 평가가 발생할 때 시스템은 테스트 세트가 훈련이나 하이퍼파라미터 최적화 중에 사용되지 않았음을 보장해야 합니다

### 요구사항 7: 모델 저장 및 배포 형식 변환

**사용자 스토리:** 모델 배포 엔지니어로서, 훈련된 모델을 다양한 플랫폼에서 사용할 수 있도록 여러 형식으로 저장하고 변환하고 싶습니다.

#### 수락 기준

1. 최종 훈련된 모델이 완성될 때 시스템은 모델을 pickle(.pkl) 파일 형식으로 저장해야 합니다
2. 모델 저장 시 시스템은 모델과 함께 전처리 파라미터와 특징 추출 설정을 포함해야 합니다
3. Apple 플랫폼 배포를 위해 시스템은 coremltools를 사용하여 pickle 모델을 Core ML(.mlmodel) 형식으로 변환하는 기능을 제공해야 합니다
4. 모델 변환 시 시스템은 입력 특징의 형태와 출력 클래스 정보를 올바르게 매핑해야 합니다
5. 변환된 모델들이 생성될 때 시스템은 각 모델 형식에 대한 사용 예제와 로딩 방법을 제공해야 합니다

### 요구사항 8: 코드 구조 및 재사용성

**사용자 스토리:** 소프트웨어 개발자로서, 잘 구조화되고 모듈화된 코드를 원하여 분류 파이프라인을 쉽게 유지보수, 확장, 재사용할 수 있기를 바랍니다.

#### 수락 기준

1. 기능을 구현할 때 시스템은 각 주요 작업에 대해 별도의 함수를 제공해야 합니다 (extract_features(), augment_noise(), train_model())
2. 코드가 작성될 때 시스템은 각 처리 단계에 대해 명확한 주석과 문서를 포함해야 합니다
3. 파이프라인을 구조화할 때 시스템은 데이터 로딩, 증강, 특징 추출, 모델 훈련, 평가를 별개의 단계로 분리해야 합니다
4. 아키텍처를 설계할 때 시스템은 추가적인 모델 유형과 특징 추출 방법의 쉬운 통합을 가능하게 해야 합니다
5. 함수를 구현할 때 시스템은 코드 구성과 가독성을 위한 Python 모범 사례를 따라야 합니다
